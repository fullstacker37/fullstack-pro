> 工厂模式定义：“Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.”(在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。)

抽象工厂这块知识，对入行以来一直写纯 JavaScript 的同学可能不太友好——因为抽象工厂在很长一段时间里，都被认为是 Java/C++ 这类语言的专利。

Java/C++ 的特性是什么？它们是强类型的静态语言。用这些语言创建对象时，我们需要时刻关注类型之间的解耦，以便该对象日后可以表现出多态性。但 JavaScript，作为一种弱类型的语言，它具有天然的多态性，好像压根不需要考虑类型耦合问题。而目前的 JavaScript 语法里，也确实不支持抽象类的直接实现，我们只能凭借模拟去还原抽象类。因此有一种言论认为，对于前端来说，抽象工厂就是鸡肋。

但现在，不要看到“抽象”两个字转身就走，鸡肋不鸡肋理解清楚了才有发言权。

### 简单工厂案例后续
在实际的业务中，我们往往面对的复杂度并非数个类、一个工厂可以解决，而是需要动用多个工厂。

我们继续看[上个小节](https://segmentfault.com/a/1190000022088395)举出的例子，简单工厂函数最后长这样：
```javascript
function Factory(name, age, career) {
    var work;
    switch(career) {
        case 'employees':
            work = ["办存款", "放贷款", "收贷款"];
        case 'president':
            work = ["喝茶", "看报纸", "..."];
        case 'chairman':
            work = ["喝水", "放贷签字", "开会"];
        case xxx:
            // 工种对应职责
        ...
    }
    return new User(name, age, career, work);
}
```
乍看之下是没什么问题，但仔细看上去首个问题就是我们把行长和普通职工放在了一起。行长和职工在职能上的差别还是很大的：首先，权限不同；其次，对一个系统的操作也不同；再者，......

那怎么办呢？要在工厂方法里加入相关的逻辑判断吗？单从功能实现上是没有问题的。但这么做实则在挖坑，因为银行的工种多着呢，不止有行长、普通职工、还有主任、支行长、分行长等，他们的权限、职能有很大的不同。如果按照这个思路，每出现一个工种就在Factory增加相应的逻辑，那首先会造成这个工厂方法异常庞大，大到最终你不敢增加/修改任何地方，生怕导致Factory出现bug影响现有系统逻辑，也使得其难以维护。其次，每增加一个工种的逻辑就需要测试人员对Factory方法整个逻辑进行回归，给测试人员带来额外的工作量。**而这一切的源头就是没有遵守软件设计的开放封闭原则**。我们再复习一下开放封闭原则的内容：对拓展开放，对修改封闭。说得更准确点，软件实体（类、模块、函数）可以扩展，但是不可修改。

### 抽象工厂模式
我们先不急于理解具体的概念，先来看下面的例子：
